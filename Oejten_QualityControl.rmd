---
title: "Quality Control of the Data for Oejten"
output: pdf_document
---
```{r include = FALSE}
knitr::opts_chunk$set(fig.height = 9, fig.width = 7, fig.crop = FALSE)
```

# Load data
## Load libraries and make folders
```{r load libraries}
rm(list = ls())
suppressMessages(library(dplyr))
suppressMessages(library(Seurat))
suppressMessages(library(patchwork))
suppressMessages(library(ggplot2))
suppressMessages(library(clustree))
# make folders, if they don't exist
# results
if (!dir.exists("results")) {
  dir.create("results")
}
# results/figures
if (!dir.exists("results/figures")) {
  dir.create("results/figures")
}
# results/tables
if (!dir.exists("results/tables")) {
  dir.create("results/tables")
}
```

## Load data
```{r load data}
# Load the .rds object created in the previous step
# see more in Oejten_CreateSeuratObject.Rmd

bm <- readRDS("data/seurat_obj/Oejten_scRNAseq.rds")
bm
```


# Preprocessing
## Add more QC metrics.
It is interesting to add metrics such as the number of mitochondrial or ribosomal genes.
```{r add more QC metrics}
# calculate the number of mitochondrial genes
bm <- PercentageFeatureSet(bm, pattern = "^MT-", col.name = "percent.mt")
# calculate the number of ribosomal genes
bm <- PercentageFeatureSet(bm, pattern = "^RPS|^RPL", col.name = "percent.ribo")

# see the new metrics
head(bm@meta.data, 5)
```

It is worth noting that the counts seem to be integers.
This is indicates that the data is not normalized.

## Visualize the QC metrics
```{r visualize the QC metrics}
# plot the QC metrics
bm %>%
  VlnPlot(
    features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"),
    group.by = "sample",
    ncol = 2, pt.size = 0
  ) -> qc_plot
qc_plot
# save plot to file
ggsave("results/figures/Oejten_QC_metrics.png",
       plot = qc_plot, dpi = 300,
       width = 10, height = 10)
```

### Relationship against metrics
We expect the number of features and counts to be positively correlated.
```{r relationship against metrics}
# plot the relationship between the number of features and counts
bm %>%
        FeatureScatter(
          feature1 = "nFeature_RNA",
          feature2 = "nCount_RNA",
          group.by = "sample"
        ) -> qc_plot
qc_plot
# save plot to file
ggsave("results/figures/Oejten_QC_metrics_relationship.png",
       plot = qc_plot, dpi = 300,
       width = 10, height = 10)
```

# Filtering
The filtering is done as stated in the paper.
We filter out those with less than 500 genes and more than 8% mitochondrial genes.
```{r filtering}
bm <- subset(bm, subset = nFeature_RNA > 500 & percent.mt < 8)
```



# Normalisation
## Log normalisation
We normalise we the default values.
```{r log normalisation}

bm <- NormalizeData(bm, normalization.method = "LogNormalize",
                    scale.factor = 10000 # scale to 10,000 reads per cell
        )
```

# Identification of highly variable features
These features are the most likely to be biologically relevant.
```{r identification of highly variable features}
# find the 2000 most variable genes
bm <- FindVariableFeatures(bm, selection.method = "vst", nfeatures = 2000)
# top 10 most variable genes
top10 <- head(VariableFeatures(bm), 10)
top10
# plot the variable features
VariableFeaturePlot(bm)
# add labels for the top 10
LabelPoints(plot = VariableFeaturePlot(bm),
            points = top10, repel = TRUE) -> vfp
vfp
# save plot to file
ggsave("results/figures/Oejten_variable_features.png",
       plot = vfp, dpi = 300,
       width = 10, height = 10)
```


As expected, the top genes are genes expressed by only a subset of immune cells.
Most of them are IG genes expressed by B cells, except for HBG2 that is expressed by erythrocytes.
More info
<details>
  <summary>More info</summary>

    Generated by ChatGTP.
    - IGLC2: Encodes a protein subunit of immunoglobulin (antibody) molecules that are expressed by B cells. Found in plasma cells, a type of mature B cell that produces large amounts of antibody.
    - IGHA1: Encodes the alpha heavy chain of immunoglobulin A (IgA) molecules, which are primarily found in mucosal tissues such as the respiratory and gastrointestinal tracts. Expressed by plasma cells and memory B cells.
    - IGKC: Encodes the kappa light chain of immunoglobulin molecules. Expressed by B cells, with higher expression in memory B cells and plasma cells.
    - IGHG1: Encodes the gamma-1 heavy chain of immunoglobulin G (IgG) molecules, which are the most abundant antibodies in the blood and tissues. Expressed by plasma cells and memory B cells.
    - IGHG3: Encodes the gamma-3 heavy chain of IgG molecules, which have a shorter half-life than other IgG subtypes. Expressed by plasma cells and memory B cells.
    - IGLC3: Encodes a protein subunit of immunoglobulin molecules. Expressed by B cells, with higher expression in plasma cells and memory B cells.
    - HBG2: Encodes the gamma-2 chain of fetal hemoglobin, which is produced during fetal development and replaced by adult hemoglobin after birth. Expressed by erythroid precursor cells in the bone marrow.
    - IGHA2: Encodes the alpha-2 heavy chain of IgA molecules. Expressed in mucosal tissues and secondary lymphoid organs, with higher expression in plasma cells and memory B cells.
    - IGLL5: Encodes a protein subunit of immunoglobulin molecules. Expressed by B cells, with higher expression in plasma cells and memory B cells.
    - IGHG4: Encodes the gamma-4 heavy chain of IgG molecules, which have a longer hinge region than other IgG subtypes. Expressed by plasma cells and memory B cells.
</details>

# Scale data
We scale the data to have a mean of 0 and variance of 1.
```{r scale data}
# run for all the features
plan("multisession", workers = 4) # multithreading
options(future.globals.maxSize = 2000 * 1024 ^ 2)
bm <- ScaleData(bm,
                 features = rownames(bm) # all features
                 )
# scale only the variable features
#bm <- ScaleData(bm,
#                features = VariableFeatures(bm) # only variable features
#                )
```

Given that we have only scaled the variable features, these are the only ones that we can analyse further.

# Linear dimensional reduction
## PCA
### Run PCA
We run PCA on the scaled data.
```{r run pca}
bm <- RunPCA(bm,
             features = VariableFeatures(bm), # only variable features
             verbose = FALSE # do not print progress
            )
# print the first 5 PCs and the top 5 genes in each direction
print(bm[['pca']], dims = 1:5, nfeatures = 5)
```
### Plot the PCA
We then plot the first 2 PCs.
```{r pca plot}
# plot pca loadings for the first 2 PCs
bm %>%
  VizDimLoadings(dims= 1:2,
                 reduction = "pca"
  ) -> pca_loadings
pca_loadings
# plot pca
bm %>%
  DimPlot(reduction = "pca", group.by = "sample") -> pca_plot
pca_plot
# save plots to file
ggsave("results/figures/Oejten_PCA_loadings.png",
       plot = pca_loadings, dpi = 300,
       width = 10, height = 10)
ggsave("results/figures/Oejten_PCA.png",
       plot = pca_plot, dpi = 300,
       width = 10, height = 10)
```

To me, it looks like the first PC is separating a very small set of the cells from the rest.


### Plot a heatmap of the PCs
We can also plot a heatmap of the PCs. It helps to identify the sources of heterogeneity in the dataset.
```{r pca heatmap}
DimHeatmap(bm,
           dims = 1:6,
           cells = 500,
           balanced = TRUE,
           fast = FALSE # function returns a ggplot object, otherwise is NULL
) -> pca_heatmap
pca_heatmap
# save plot to file
ggsave("results/figures/Oejten_PCA_heatmap.png",
       plot = pca_heatmap, dpi = 300,
       width = 10, height = 10)
```

The expression in the first PC is very heterogeneous, with some cells having very high expression and others having very low expression when it comes to the negative direction of the PC.

# Dimensionality of the data
How many dimensions do we need to capture most of the variance?


## Elbow plot
We can also use the elbow plot to estimate the number of dimensions needed to capture most of the variance.
This is faster than the Jackstraw plot.
```{r elbow plot}
ElbowPlot(bm, ndims = 50 ) -> elbow_plot
elbow_plot
# save plot to file
ggsave("results/figures/Oejten_elbow.png",
       plot = elbow_plot, dpi = 300,
       width = 10, height = 10)
```

Elbow plot suggest that we need at least 20 dimensions to capture most of the variance.

# Clustering

## find neighbours and clusters
We can use the FindNeighbors function to find the neighbours of each cell and the FindClusters function to cluster the cells.
```{r find neighbours}
plan("multisession", workers = 40)
bm <- FindNeighbors(bm,
                    dims = 1:20
                    )

```
```{r find clusters}
plan("multisession", workers = 40)
# find clusters at different resolutions
# Select a range of resolutions
resolution.range <- seq(from = 0, to = 1, by = 0.25)

# Find clusters using a range of resolutions
bm <- Seurat::FindClusters(object = bm,
                           resolution = resolution.range
                           )
bm <- SetIdent(bm, value = "seurat_clusters")
```


## Plot clusters
We can plot the clusters using the DimPlot function.
```{r plot clusters}
clustree(bm) -> clustree_plot
clustree_plot

# plot clusters
bm %>%
  DimPlot(reduction = "pca") -> clusters_plot
clusters_plot
# save plot to file
ggsave("results/figures/Oejten_clusters.png",
       plot = clusters_plot, dpi = 300,
       width = 10, height = 10)
```



# Non-linear dimensional reduction
## UMAP
We can use the UMAP algorithm to reduce the dimensionality of the data.
```{r umap}
bm <- RunUMAP(bm,
              dims = 1:20
              )
```
###  plot umap
We can plot the UMAP.
```{r umap plot}
# plot umap with labels
bm %>%
  DimPlot(reduction = "umap",
          label = TRUE,
          group.by = "seurat_clusters" ) -> umap_plot
umap_plot
# save plot to file
ggsave("results/figures/Oejten_umap.png",
       plot = umap_plot, dpi = 300,
       width = 10, height = 10)
```

### UMAP by sample
We can also plot the UMAP by sample.
```{r umap by sample}
bm %>%
  DimPlot(reduction = "umap",
          group.by = "sample") -> umap_by_sample_plot
umap_by_sample_plot
# save plot to file
ggsave("results/figures/Oejten_umap_by_sample.png",
       plot = umap_by_sample_plot, dpi = 300,
       width = 10, height = 10)
```


# Marker genes

## Find marker genes for each cluster

We can use the FindAllMarkers function to find marker genes for each cluster.
```{r find marker genes}
# parallelize
plan("multisession", workers = 40)
# find markers
bm.markers <- FindAllMarkers(bm,
                     only.pos = TRUE,
                     min.pct = 0.25,
                     logfc.threshold = 0.25
                     )
bm.markers %>%
    group_by(cluster) %>%
    slice_max(n = 20, order_by = avg_log2FC) -> top20markers

# save to file
write.csv(top20markers, "results/tables/Oejten_top20markers.csv")
```

## Visualise marker genes
We can plot some of the markers genes to see if they are indeed markers.

The reference paper lists these 4 markers as examples.
- CD3D: expressed in T cells, it is the delta chain of the T cell receptor
- HBD: it is Hemoglobin beta chain, expressed in erythrocytes
- CD79A: expressed in B cells, it is the alpha chain of the B cell receptor
- NKG7: expressed in NK cells, it is the ligand for the NK cell receptor NKG2D
- CD14: expressed in monocytes

```{r plot marker genes}
# violin plots
bm %>%
  VlnPlot(feature = c("CD3D", "HBD", "CD79A", "NKG7", "CD14", "PROM1"),
          group.by = "seurat_clusters") -> marker_genes_vplot
marker_genes_vplot
# on umap
bm %>%
  FeaturePlot(feature = c("CD3D", "HBD", "CD79A", "NKG7", "CD14", "PROM1"),
              cols = c("black", "red"),
              pt.size = 0.005) -> marker_genes_fplot
marker_genes_fplot
# save plots to file
ggsave("results/figures/Oejten_marker_genes_violin.png",
       plot = marker_genes_vplot, dpi = 300,
       width = 10, height = 10)
ggsave("results/figures/Oejten_marker_genes_umap.png",
         plot = marker_genes_fplot, dpi = 300,
         width = 10, height = 10)
```

The FeaturePlot makes sense. NKG7 and CD3D are expressed in the NK and T cells, respectively. They are somewhat related
when it comes to transcriptional profiles.


## Heatmap of marker genes
We can also plot a heatmap of the marker genes.
```{r heatmap of marker genes}
bm.markers %>%
  group_by(cluster) %>%
  top_n(n = 5, wt = avg_log2FC) -> top5markers

DoHeatmap(subset(bm, downsample = 100), features = top5markers$gene,
          group.by = "seurat_clusters") -> marker_genes_heatmap
marker_genes_heatmap
# save plot to file
ggsave("results/figures/Oejten_marker_genes_heatmap.png",
       plot = marker_genes_heatmap, dpi = 300,
       width = 10, height = 10)
```

Warning in DoHeatmap(bm, features = top5markers$gene) :
  The following features were omitted as they were not found in the scale. Data slot for the RNA: GLTSCR2, Ã§IFITM1, RPS26, GIMAP7, AC090498.1, TRAC, CCR7, RPS12, RPLP2, LTB, RPL30, JUNB


They are not found there probably because they do not show variation. We only scaled the variable genes.
How is it possible that they are markers if they are not variable features?
Variable features show variation across all cells.
Maybe it is better to scale all genes and then find the markers.


Also, it doesn't plot because there are too many cells (>30k).
https://github.com/satijalab/seurat/issues/2724
We can use the subset function to select a subset of cells. (implemented up there)

# save the Seurat object
We can save the Seurat object to a file.
```{r save seurat object}
saveRDS(bm, "data/seurat_obj/Oejten_seurat_QC.rds", compress = FALSE)
```

# load the Seurat object
We can load the Seurat object from a file.
```{r load seurat object}
bm <- readRDS("data/seurat_obj/Oejten_seurat_QC.rds")
# marker genes csv
bm.markers <- read.csv("results/tables/Oejten_top20markers.csv")
```


