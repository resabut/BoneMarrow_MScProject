---
title: "Quality Control of the Data for Oejten"
output: html_notebook
---


# Load data
## Load libraries and make folders
```{r load libraries}
rm(list = ls())
suppressMessages(library(dplyr))
suppressMessages(library(Seurat))
suppressMessages(library(patchwork))
suppressMessages(library(ggplot2))
# make folders, if they don't exist
# results
if (!dir.exists("results")) {
  dir.create("results")
}
# results/figures
if (!dir.exists("results/figures")) {
  dir.create("results/figures")
}

```

## Load data
```{r load data}
# Load the .rds object created in the previous step
# see more in Oejten_CreateSeuratObject.Rmd

bm <- readRDS("data/seurat_obj/Oejten_scRNAseq.rds")
bm
```
```
```

# Preprocessing
## Add more QC metrics.
It is interesting to add metrics such as the number of mitochondrial or ribosomal genes.
```{r add more QC metrics}
# calculate the number of mitochondrial genes
bm <- PercentageFeatureSet(bm, pattern = "^MT-", col.name = "percent.mt")
# calculate the number of ribosomal genes
bm <- PercentageFeatureSet(bm, pattern = "^RPS|^RPL", col.name = "percent.ribo")
# add short name for sample origin
# e.g. "GSM339161_A" -> "A"
bm[["sample"]] <- strsplit(bm$orig.ident, "_") %>% sapply(function(x) x[2])
# see the new metrics
head(bm@meta.data, 5)
```

It is worth noting that the counts seem to be integers.
This is indicates that the data is not normalized.

## Visualize the QC metrics
```{r visualize the QC metrics}
# plot the QC metrics
bm %>%
  VlnPlot(
    features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"),
    group.by = "sample",
    ncol = 2, pt.size = 0
  ) -> qc_plot
qc_plot
# save plot to file
ggsave("results/figures/Oejten_QC_metrics.png",
       plot = qc_plot, dpi = 300,
       width = 10, height = 10)
```

### Relationship against metrics
We expect the number of features and counts to be positively correlated.
```{r relationship against metrics}
# plot the relationship between the number of features and counts
bm %>%
        FeatureScatter(
          feature1 = "nFeature_RNA",
          feature2 = "nCount_RNA",
          group.by = "sample"
        ) -> qc_plot
qc_plot
# save plot to file
ggsave("results/figures/Oejten_QC_metrics_relationship.png",
       plot = qc_plot, dpi = 300,
       width = 10, height = 10)
```

# Filtering
The filtering is done as stated in the paper.
We filter out those with less than 500 genes and more than 8% mitochondrial genes.
```{r filtering}
bm <- subset(bm, subset = nFeature_RNA > 500 & percent.mt < 8)
```



# Normalisation
## Log normalisation
We normalise we the default values.
```{r log normalisation}

bm <- NormalizeData(bm, normalization.method = "LogNormalize",
                    scale.factor = 10000 # scale to 10,000 reads per cell
        )
```

# Identification of highly variable features
These features are the most likely to be biologically relevant.
```{r identification of highly variable features}
# find the 2000 most variable genes
bm <- FindVariableFeatures(bm, selection.method = "vst", nfeatures = 2000)
# top 10 most variable genes
top10 <- head(VariableFeatures(bm), 10)
top10
# plot the variable features
VariableFeaturePlot(bm)
# add labels for the top 10
LabelPoints(plot = VariableFeaturePlot(bm),
            points = top10, repel = TRUE) -> vfp
vfp
# save plot to file
ggsave("results/figures/Oejten_variable_features.png",
       plot = vfp, dpi = 300,
       width = 10, height = 10)
```


As expected, the top genes are genes expressed by only a subset of immune cells.
Most of them are IG genes expressed by B cells, except for HBG2 that is expressed by erythrocytes.
More info
<details>
  <summary>More info</summary>

    Generated by ChatGTP.
    - IGLC2: Encodes a protein subunit of immunoglobulin (antibody) molecules that are expressed by B cells. Found in plasma cells, a type of mature B cell that produces large amounts of antibody.
    - IGHA1: Encodes the alpha heavy chain of immunoglobulin A (IgA) molecules, which are primarily found in mucosal tissues such as the respiratory and gastrointestinal tracts. Expressed by plasma cells and memory B cells.
    - IGKC: Encodes the kappa light chain of immunoglobulin molecules. Expressed by B cells, with higher expression in memory B cells and plasma cells.
    - IGHG1: Encodes the gamma-1 heavy chain of immunoglobulin G (IgG) molecules, which are the most abundant antibodies in the blood and tissues. Expressed by plasma cells and memory B cells.
    - IGHG3: Encodes the gamma-3 heavy chain of IgG molecules, which have a shorter half-life than other IgG subtypes. Expressed by plasma cells and memory B cells.
    - IGLC3: Encodes a protein subunit of immunoglobulin molecules. Expressed by B cells, with higher expression in plasma cells and memory B cells.
    - HBG2: Encodes the gamma-2 chain of fetal hemoglobin, which is produced during fetal development and replaced by adult hemoglobin after birth. Expressed by erythroid precursor cells in the bone marrow.
    - IGHA2: Encodes the alpha-2 heavy chain of IgA molecules. Expressed in mucosal tissues and secondary lymphoid organs, with higher expression in plasma cells and memory B cells.
    - IGLL5: Encodes a protein subunit of immunoglobulin molecules. Expressed by B cells, with higher expression in plasma cells and memory B cells.
    - IGHG4: Encodes the gamma-4 heavy chain of IgG molecules, which have a longer hinge region than other IgG subtypes. Expressed by plasma cells and memory B cells.
</details>

# Scale data
We scale the data to have a mean of 0 and variance of 1.
```{r scale data}
# run for all the features takes too long
# bm <- ScaleData(bm,
#                 features = rownames(bm) # all features
#                 )
# scale only the variable features
bm <- ScaleData(bm,
                features = VariableFeatures(bm) # only variable features
                )
```

Given that we have only scaled the variable features, these are the only ones that we can analyse further.

# Linear dimensional reduction
## PCA
### Run PCA
We run PCA on the scaled data.
```{r run pca}
bm <- RunPCA(bm,
             features = VariableFeatures(bm), # only variable features
             verbose = FALSE # do not print progress
            )
# print the first 5 PCs and the top 5 genes in each direction
print(bm[['pca']], dims = 1:5, nfeatures = 5)
```
### Plot the PCA
We then plot the first 2 PCs.
```{r pca plot}
# plot pca loadings for the first 2 PCs
bm %>%
  VizDimLoadings(dims= 1:2,
                 reduction = "pca"
  ) -> pca_loadings
pca_loadings
# plot pca
bm %>%
  DimPlot(reduction = "pca", group.by = "sample") -> pca_plot
pca_plot
# save plots to file
ggsave("results/figures/Oejten_PCA_loadings.png",
       plot = pca_loadings, dpi = 300,
       width = 10, height = 10)
ggsave("results/figures/Oejten_PCA.png",
       plot = pca_plot, dpi = 300,
       width = 10, height = 10)
```

To me it looks like the first PC is separating a very small set of the cells from the rest.


### Plot a heatmap of the PCs
We can also plot a heatmap of the PCs. It helps to identify the sources of heterogeneity in the dataset.
```{r pca heatmap}
DimHeatmap(bm, dims = 1:6, cells = 500, balanced = TRUE) -> pca_heatmap
pca_heatmap
# save plot to file
ggsave("results/figures/Oejten_PCA_heatmap.png",
       plot = pca_heatmap, dpi = 300,
       width = 10, height = 10)
```

The expression in the first PC is very heterogeneous, with some cells having very high expression and others having very low expression when it comes to the negative direction of the PC.

# Dimensionality of the data
How many dimensions do we need to capture most of the variance?

## Jackstraw plot
We can use the jackstraw plot to estimate the number of dimensions needed to capture most of the variance.
```{r jackstraw plot, eval = TRUE}
# run jackstraw
bm <- JackStraw(bm, num.replicate = 100, dims = 50)
bm <- ScoreJackStraw(bm, dims = 1:50)
# plot jackstraw
JackStrawPlot(bm, dims = 1:50) -> jackstraw_plot
jackstraw_plot
# save plot to file
ggsave("results/figures/Oejten_jackstraw.png",
       plot = jackstraw_plot, dpi = 300,
       width = 10, height = 10)
```

Signficance is conserved even at 30 dimensions.

## Elbow plot
We can also use the elbow plot to estimate the number of dimensions needed to capture most of the variance.
This is faster than the Jackstraw plot.
```{r elbow plot}
ElbowPlot(bm, ndims = 50 ) -> elbow_plot
elbow_plot
# save plot to file
ggsave("results/figures/Oejten_elbow.png",
       plot = elbow_plot, dpi = 300,
       width = 10, height = 10)
```

Elbow plot suggest that we need at least 20 dimensions to capture most of the variance.

# Clustering

## find neighbours and clusters
We can use the FindNeighbors function to find the neighbours of each cell and the FindClusters function to cluster the cells.
```{r find neighbours and clusters}
bm <- FindNeighbors(bm,
                    dims = 1:20
                    )
bm <- FindClusters(bm,
                      resolution = 0.5
                     )
# plot clusters
bm %>%
  DimPlot(reduction = "pca") -> clusters_plot
clusters_plot
# save plot to file
ggsave("results/figures/Oejten_clusters.png",
       plot = clusters_plot, dpi = 300,
       width = 10, height = 10)
```


# Non-linear dimensional reduction
## UMAP
We can use the UMAP algorithm to reduce the dimensionality of the data.
```{r umap}
bm <- RunUMAP(bm,
              dims = 1:20
              )
# plot umap
bm %>%
  DimPlot(reduction = "umap") -> umap_plot
umap_plot
# save plot to file
ggsave("results/figures/Oejten_umap.png",
       plot = umap_plot, dpi = 300,
       width = 10, height = 10)
```
