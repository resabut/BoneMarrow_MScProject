---
title: "Following Guided Clustering Tutorial from Satija Lab"
output:
    pdf_document: default
---

Here I apply this for the dataset:
[Article](https://insight.jci.org/articles/view/124928)
[Dataset repository](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120221)

# Initialisation

First, import the appropriate libraries:
```{r}
library(dplyr)
library(Seurat)
library(patchwork)
```

Then, read in the data:
```{r}
# Read in the data
bm.data <- Read10X(data.dir = "data/GSE120221_RAW/A")
# initialize the Seurat object with the raw (non-normalized data).
bm <- CreateSeuratObject(counts = bm.data, project = "bm", min.cells = 3, min.features = 200)
bm

```

## Exploratory
Look at some genes
```{r}
# First 10 genes, first 30 cells
bm.data[1:10, 1:30]
```
The point correspond to 0 matrix. The matrix is sparse, it occupies less memory than a dense matrix.
See how big it is when dense versus sparse:
```{r}
dense.size <- object.size(as.matrix(bm.data))
dense.size
sparse.size <- object.size(bm.data)
sparse.size
dense.size/sparse.size
```

# Preprocessing
## QC and selecting cells for further analysis

```{r}
# see QC metrics in Seurat
# see the data for the first 5 cells
head(bm@meta.data,5)
```
# add number of mitochondrial genes
```{r}
# add number of mitochondrial genes
bm[["percent.mt"]] <- PercentageFeatureSet(bm, pattern = "^MT-")
# add number of ribosomal genes
bm[["percent.ribo"]] <- PercentageFeatureSet(bm, pattern = "^RP[SL]")
# see metadata
head(bm@meta.data,5)
```

Visualize QC metrics
```{r}
# Visualize QC metrics
VlnPlot(bm, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"), ncol = 2)
```


We can also see the relationship among the QC metrics
```{r}
# nFeature vs nCount
plot1 <- FeatureScatter(bm, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# nCount vs percent.mt
plot2 <- FeatureScatter(bm, feature1 = "nCount_RNA", feature2 = "percent.mt")
# nCount vs percent.ribo
plot3 <- FeatureScatter(bm, feature1 = "nCount_RNA", feature2 = "percent.ribo")
# nFeature vs percent.mt
plot4 <- FeatureScatter(bm, feature1 = "nFeature_RNA", feature2 = "percent.mt")
plot1 + plot2 + plot3 + plot4
```

Now we filter the data as stated in the paper
```{r}
# filter cells with less than 500 genes and less than 8% mitochondrial genes
bm <- subset(bm, subset = nFeature_RNA > 500 & percent.mt < 8)
```

We can make the plots again to see how the data has changed
```{r}
# nFeature vs nCount
plot5 <- FeatureScatter(bm, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
# nCount vs percent.mt
plot6 <- FeatureScatter(bm, feature1 = "nCount_RNA", feature2 = "percent.mt")
# nCount vs percent.ribo
plot7 <- FeatureScatter(bm, feature1 = "nCount_RNA", feature2 = "percent.ribo")
# nFeature vs percent.mt
plot8 <- FeatureScatter(bm, feature1 = "nFeature_RNA", feature2 = "percent.mt")
plot1 + plot5
plot2 + plot6
plot3 + plot7
plot4+ plot8

```

## Normalization
Normalisation in the tutorial is done by log transformation of the data. This is done by the function `NormalizeData(
```{r}
# Normalize the data
bm <- NormalizeData(bm, normalization.method = "LogNormalize", scale.factor = 10000)
# these are the default values so it could be run as following
# bm <- NormalizeData(bm)
```
## Identification of highly variable genes (features)
This step is called feature selection. Focusing on these genes helps to highlight biological signal in this type of analysis. The function `FindVariableFeatures` is used to identify the highly variable genes. The default is to use the 2000 most variable genes.
```{r}
# Find the 2000 most variable genes
bm <- FindVariableFeatures(bm, selection.method = "vst", nfeatures = 2000)
top10 <- head(VariableFeatures(bm), 10)
# plot variable features
# no labels
plot1 <- VariableFeaturePlot(bm)
# with labels
plot2 <- LabelPoints(plot = VariableFeaturePlot(bm), points = top10)
plot1 + plot2
top10
```
Looking at the top 10 more variable genes we see that they're expressed only in certain types of immune cells, and not all. This is a good sign that the feature selection is working.
- IGKC: Expressed in B cells.
- IGHG1: Expressed in B cells.
- IGHG3: Expressed in B cells.
- IGHA1: Expressed in B cells and plasma cells.
- MZB1: Expressed in B cells and plasma cells.
- IGHGP: This is a non-functional pseudogene and is not expressed.
- PRTN3: Expressed in neutrophils, eosinophils, and mast cells.
- ELANE: Expressed in neutrophils.
- IGLC2: Expressed in B cells and plasma cells.
- PTGDS: Expressed in various tissues, including mast cells, macrophages, and brain cells

## Scale the data
It needs to be run before dimensional reduction techniques.
- Mean to 0
- Variance to 1

In this example it is run for all features, but it is possible to run it only for the variable features.
```{r}
# Scale the data
all.genes <- rownames(x = bm)
bm <- ScaleData(bm, features = all.genes)
# only for variable features
# bm <- ScaleData(bm, features = VariableFeatures(object = bm))
```


## Perform linear dimensional reduction
PCA on the scaled data, we use the subset that we have selected as variable features.
```{r}
bm <- RunPCA(bm, features = VariableFeatures(object = bm))
# see text pca
print(bm[['pca']], dims = 1:5, nfeatures = 5)
# plot pca loadings
VizDimLoadings(bm, dims = 1:2, reduction = "pca")
# plot pca plot
DimPlot(bm, reduction = "pca")

```

Now we can create a heatmap to identify the sources of heterogeneity in our dataset.
```{r}
# Create the heatmap
DimHeatmap(bm, dims = 1:6, cells=500, balanced = TRUE)
```

The top 15 and bottom 15 of genes with the highest and lowest PC loadings are displayed. The top 15 genes are expressed in the same direction as the PC, and the bottom 15 genes are expressed in the opposite direction. The genes are ordered by the magnitude of the PC loading. The heatmap shows the expression of these genes in the cells.
The cells are ordered by the distance to the origin of the PC. The cells that are closest to the origin are the ones that have the highest expression of the genes that are ordered at the top of the heatmap. The cells that are furthest from the origin are the ones that have the highest expression of the genes that are ordered at the bottom of the heatmap.

I do not quite understand the order of the cells

## Determine the 'dimensionality' of the data
There is a lot of technical noise. We can cluster the cells by their PCA scores. The top PC will help us do so -> but how many should we include?

Some resampling test to solve this issue.
```{r}
# Determine the number of PCs to use
bm <- JackStraw(bm, num.replicate = 100)
bm <- ScoreJackStraw(bm, dims = 1:20) # 1:20 is the default, number of PC
# plot the results
JackStrawPlot(bm, dims = 1:20)
```

Basically all of the first 20 are quite signficant, I can do an elbow plot, that is faster, for even more PCs.
```{r}
# elbow plot
ElbowPlot(bm, ndims = 40)
```

As we can see, it is only after 30 or so that the curve starts to flatten out. This elbow is not very clear.
In this case, we will use the first 20 PCs.
Some advice:
- PCs that are not very signficant can be related to rare subsets that are hard to distinguish from background noise.
- More PCs in downstream analyses usually do not alter the conclusions.
- Less PCs however can lead to loss of power, more error and different results.

## Clustering
In Seurat v3 it is graph-based.
```{r}
# Run the standard workflow for visualization and clustering
bm <- FindNeighbors(bm, dims = 1:20)
bm <- FindClusters(bm, resolution = 0.5)
# look at the firrst 5 cells
head(Idents(bm), 5)
# plot the clusters
DimPlot(bm, reduction = "pca")
```

Some clusters look more clear than others.

## Run non-linear dimensional reduction
tSNE or UMAP
From the tutorial:
> The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots.

```{r}
# install umap
# reticulate::py_install(packages = 'umap-learn')
# then it tells me to install miniconda because it requires python.

# Run umap
bm <- RunUMAP(bm, dims = 1:20) # 20 PCs
# plot umap
DimPlot(bm, reduction = "umap", label = TRUE)
```


As expected, the clusters are preserved in the non-linear dimension reduction. They group in the graph.

# Save the object
```{r}
# save the object
saveRDS(bm, file = "Results/Seurat_obj/bm_tutorial.rds")
```

No STD out means that it was saved correctly.

## Load RDS
```{r}
# load the object
bm <- readRDS(file = "Results/Seurat_obj/bm_tutorial.rds")
```


## Finding differentially expressed genes

Find markers for each cluster
```{r}
# find markers of cluster 2
cluster2.markers <- FindMarkers(bm,
                                ident.1 = 2, # cluster 2
                                min.pct = 0.25) # genes expressed in at least 25% of cells in cluster 2
# look at the top 5
head(cluster2.markers, n = 5)
```

For some reason the table row name do not show here
                p_val avg_log2FC    pct.1 pct.2     p_val_adj
VCAN     0.000000e+00   2.736153    0.884 0.081  0.000000e+00
CD14     0.000000e+00   2.370533    0.812 0.048  0.000000e+00
S100A12 1.550285e-288   4.068159    0.919 0.140 2.668505e-284
FCN1    2.284608e-285   3.506080    0.991 0.202 3.932496e-281
CLEC7A  1.767414e-279   2.082199    0.832 0.084 3.042249e-275

From chatGPT:

    VCAN:
    Function: Encodes for Versican, a large extracellular matrix proteoglycan involved in cell adhesion, proliferation, and differentiation.
    Immune/Bone marrow cell type expression: Expressed in various immune cells including macrophages, dendritic cells, and T cells.
    CD14:

    Function: Encodes for CD14, a glycoprotein that acts as a co-receptor for lipopolysaccharide (LPS) and other bacterial cell wall components.
    Immune/Bone marrow cell type expression: Expressed in monocytes, macrophages, and dendritic cells.
    S100A12:

    Function: Encodes for S100A12, a calcium-binding protein that plays a role in the regulation of inflammatory processes.
    Immune/Bone marrow cell type expression: Expressed in neutrophils and other myeloid cells.
    FCN1:

    Function: Encodes for Ficolin-1, a protein involved in innate immune responses and complement activation.
    Immune/Bone marrow cell type expression: Expressed in macrophages, dendritic cells, and other immune cells.
    CLEC7A:

    Function: Encodes for C-type lectin domain family 7 member A, also known as Dectin-1, a pattern recognition receptor involved in the recognition of fungal pathogens.
    Immune/Bone marrow cell type expression: Expressed in dendritic cells, macrophages, and other myeloid cells.

We can also identify markers that distinguish one cluster from others.
```{r}
# find markers that distinguish cluster 5 from 0 and 3
cluster5.markers <- FindMarkers(bm,
                                ident.1 = 5, # cluster 5
                                ident.2 = c(0, 3), # cluster 0 and 3
                                min.pct = 0.25) # genes expressed in at least 25% of cells in cluster 5
# look at the top 5
head(cluster5.markers, n = 5)
```

    KLF1	2,36573e-209	2,13068	0,985000	0,0350000	4,07214e-205
    RHAG	4,63502e-208	1,75089	0,930000	0,0150000	7,97825e-204
    TMEM56	2,32635e-188	1,18944	0,830000	0,00700000	4,00435e-184
    SMIM1	3,17772e-180	1,48409	0,905000	0,0330000	5,46981e-176
    HBQ1	3,48243e-178	1,15439	0,850000	0,0210000	5,99430e-174
    GFI1B	1,19419e-177	1,06177	0,790000	0,00900000	2,05556e-173


Then we can find markers for every cluster compared to all remaining cells. In this case, we only report the positive markers.
```{r}
# find markers for all clusters
bm.markers <- FindAllMarkers(bm, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# show the top 2 for each cluster
bm.markers %>%
    group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC) # top 2 markers for each cluster
```

### Visualize marker expression
```{r}
# for two genes
VlnPlot(bm, features = c("VCAN", "CD14"))
```

To add the raw counts
```{r}
# for another two genes
VlnPlot(bm, features = c("S100A12", "FCN1"),
        assay = "RNA", # RNA assay
        slot ="counts", # raw counts
        log = TRUE # log scale
        )
```

### Visualize marker expression on the UMAP plot
```{r}
# for 9 genes
FeaturePlot(bm, features = c("VCAN", "CD14", "S100A12", "FCN1", "CLEC7A", "KLF1", "RHAG", "TMEM56", "SMIM1"),
            cols = c("blue", "red"))
```

### Heatmap of top markers
```{r}
# heatmap of top markers, top10 is too many for this dataset
bm.markers %>%
    group_by(cluster) %>%
    top_n(n = 5, wt = avg_log2FC) -> top5

DoHeatmap(bm, features = top5$gene)
```

We can see that some clusters share similar markers. For example, cluster 0 and 1 share expression of top markers.

# Assigning cell type identity to clusters
In the tutorial they already know which markers correspond to what.


# save the file again
```{r}
# save the object
saveRDS(bm, file = "Results/Seurat_obj/bm_tutorial2.rds")
```